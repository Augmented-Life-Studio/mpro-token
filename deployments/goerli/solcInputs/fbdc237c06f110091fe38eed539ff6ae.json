{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/MPROMasterDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ninterface IJAKANTToken is IERC20 {\n    function mint(address account, uint256 amount) external;\n\n    function maxCap() external pure returns (uint256);\n}\n\n/**\n * @title MPRO Master Distributor Contract\n * @dev The JAKANTMasterDistributor contract manages token distribution and related operations.\n * It is responsible for distributing tokens to eligible recipients based on specified rules and\n * configurations. This contract utilizes the AccessControl feature for role-based access control.\n *\n * This contract extends the Context and AccessControl contracts to leverage their functionality.\n * Role-based access control allows specific roles to perform authorized actions within the contract,\n * ensuring proper governance and security.\n */\ncontract JAKANTMasterDistributor is Context, AccessControl, Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Struct representing a distribution reduction configuration.\n     *\n     * This struct defines a configuration for reducing the daily token distribution over time. It\n     * consists of two fields:\n     * - `reductionTimestamp`: The timestamp at which the reduction in distribution should take effect.\n     * - `daylyDistribution`: The daily distribution amount of tokens after the reduction.\n     *\n     * Instances of this struct are typically used in an array to specify different reduction\n     * configurations over time. The reduction timestamp marks when the daily distribution amount\n     * should change.\n     */\n    struct DistributionReduction {\n        uint256 reductionTimestamp;\n        uint256 daylyDistribution;\n    }\n\n    /**\n     * @dev Constant representing the number of seconds in a day.\n     *\n     * This constant defines the number of seconds in a day, which is used for time calculations\n     * within the contract. It is set to the standard value of 86,400 seconds per day.\n     */\n    uint256 constant SECONDS_PER_DAY = 600;\n\n    bytes32 public constant JAKANT_MASTER_DISTRIBUTOR_ROLE =\n        keccak256(\"JAKANT_MASTER_DISTRIBUTOR_ROLE\");\n    bytes32 public constant DISTRIBUTIONS_ADMINISTRATOR_ROLE =\n        keccak256(\"DISTRIBUTIONS_ADMINISTRATOR_ROLE\");\n    bytes32 public constant DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER =\n        keccak256(\"DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER\");\n    bytes32 public constant LISTER_ROLE = keccak256(\"LISTER_ROLE\");\n\n    IJAKANTToken public mproToken;\n\n    mapping(bytes32 => bool) public assignedRoles;\n\n    /**\n     * @dev Internal mapping to manage blocklisted addresses.\n     *\n     * This mapping associates addresses (keys) with boolean values to maintain a list of addresses\n     * that are considered \"blocklisted\" within the contract's logic. If an address is included in\n     * this mapping with a `true` value, it indicates that the address is blocklisted and may be\n     * subject to certain restrictions or limitations imposed by the contract.\n     *\n     * The mapping is typically used in access control mechanisms and other parts of the contract's\n     * logic to determine the behavior or privileges associated with addresses based on their\n     * blocklist status.\n     */\n    mapping(address => bool) internal blocklisted;\n\n    /**\n     * @dev Internal mapping to manage whitelisted addresses.\n     *\n     * This mapping associates addresses (keys) with boolean values to maintain a list of addresses\n     * that are considered \"whitelisted\" within the contract's logic. If an address is included in\n     * this mapping with a `true` value, it indicates that the address is whitelisted and may have\n     * special privileges or exemptions within the contract.\n     *\n     * The mapping is typically used in access control mechanisms and other parts of the contract's\n     * logic to determine the behavior or privileges associated with addresses based on their\n     * whitelist status.\n     */\n    mapping(address => bool) internal whitelisted;\n\n    /**\n     * @dev Timestamp indicating when token distribution starts.\n     *\n     * This public state variable stores the Unix timestamp (in seconds) that marks the beginning\n     * of the token distribution period. The value is set during the contract initialization and\n     * can be updated by specific functions within the contract, depending on the contract's logic.\n     *\n     * The distributionStartTimestamp is used in various functions to determine whether the\n     * distribution period has begun. This allows for conditional logic based on the time, such as\n     * enabling token distributions only after this timestamp is reached.\n     *\n     * Being a public variable, it can only be accessed and modified by functions within this\n     * contract, providing a controlled and secure way to manage the start of the distribution phase.\n     */\n    uint256 public distributionStartTimestamp;\n\n    /**\n     * @dev public immutable variable representing the deadline for the distribution start timestamp.\n     *\n     * This variable is used to store an immutable timestamp that defines the deadline for the\n     * distribution start timestamp within the contract. It is typically set during contract\n     * initialization and remains constant throughout the contract's lifetime.\n     *\n     * The distribution start timestamp deadline indicates the latest permissible timestamp for\n     * starting the distribution of tokens. After this deadline, distribution start timestamps\n     * beyond this value will not be accepted.\n     */\n    uint256 public immutable distributionStartTimestampDeadLine;\n\n    /**\n     * @dev public variable to keep track of the total tokens distributed.\n     *\n     * This variable is used to maintain a count of the total tokens that have been distributed\n     * within the contract. It starts at zero and is updated whenever tokens are distributed to\n     * recipients.\n     *\n     * It serves as a record of the cumulative tokens distributed and is often used to enforce\n     * distribution limits or to check the available tokens for distribution.\n     */\n    uint256 public distributedTokens = 0;\n\n    /**\n     * @dev public constant representing the initial daily distribution of tokens.\n     *\n     * This constant defines the initial daily distribution of tokens within the contract. It\n     * represents a fixed amount of tokens that are distributed daily as part of a distribution\n     * mechanism.\n     *\n     * The value is expressed in the contract's token decimals, and it remains constant throughout\n     * the contract's lifetime.\n     */\n    uint256 public constant initialDaylyDistribution = 250_000 * 10 ** 18;\n\n    /**\n     * @dev Public array to store distribution reduction configurations.\n     *\n     * This dynamic array stores instances of the `DistributionReduction` struct, representing\n     * configurations for reducing the daily token distribution over time. Each element of the array\n     * specifies a different reduction configuration, and the array can grow as more configurations\n     * are added.\n     *\n     * These configurations determine when and how the daily distribution amount of tokens changes\n     * over time, allowing for flexibility in managing token distribution within the contract.\n     */\n    DistributionReduction[] public distributionReductions;\n\n    /**\n     * @dev Public variable representing the burn rate for tokens.\n     *\n     * This variable determines the burn rate for tokens within the contract, expressed as a\n     * percentage. A burn rate of 1000 corresponds to 10%, where a portion of tokens is burned\n     * during certain operations. A burn rate of 10000 would represent 100%.\n     *\n     * The value of this variable can be adjusted to control the rate at which tokens are burned\n     * during specific actions, impacting the total token supply over time.\n     */\n    uint256 public burnRate = 1000; // 10000 = 100%\n\n    /**\n     * @dev Modifier to check and enable distribution reduction configurations.\n     *\n     * This modifier is used to validate and enable distribution reduction configurations. It checks\n     * that the provided `_reductionTimestamp` and `_reductionAmount` meet certain criteria to ensure\n     * that reductions are allowed. The criteria include:\n     *\n     * - `_reductionTimestamp` must be greater than the timestamp of the last reduction.\n     * - `_reductionTimestamp` must be greater than or equal to the current timestamp plus 30 days.\n     * - `_reductionAmount` must be greater than or equal to half of the previous daily distribution.\n     *\n     * If all criteria are met, the modifier allows the decorated function or operation to proceed.\n     * Otherwise, it reverts with specific error messages.\n     */\n\n    event Distributed(address indexed _to, uint256 amount);\n    event SetDistribiutionStartTime(uint256 _startTime);\n    event AddDistributionReduction(\n        uint256 _redutionTimestamp,\n        uint256 _reductionAmount\n    );\n    event SetJAKANTToken(address _mproTokenAddress);\n    event SetBurnRate(uint256 _burnRate);\n    event SetDistributorTimeAdministratorRoleManager(\n        address _roleManagerAddress\n    );\n    event SetDistributorTimeAdministratorRole(address _roleManagerAddress);\n\n    /**\n     * @dev Modifier that enforces rules for reduction in distribution. It ensures that a new distribution\n     * reduction can only be set after a certain period from the last reduction, and the new reduction amount\n     * must be within specific limits compared to the last reduction amount.\n     *\n     * The modifier checks against the last entry in the `distributionReductions` array (if it exists) to\n     * enforce the following:\n     * 1. The new reduction timestamp must be at least 183 days after the last reduction's timestamp.\n     * 2. The new daily distribution amount must not be more than half of the last reduction's daily distribution.\n     * 3. The new daily distribution amount must not be more than the last reduction's daily distribution multiplied by 2.\n     *\n     * This ensures a controlled and limited reduction of distribution over time.\n     *\n     * @param _reductionTimestamp The timestamp when the new reduction is intended to start.\n     * @param _reductionAmount The new daily distribution amount after the reduction.\n     */\n    modifier reductionEnabled(\n        uint256 _reductionTimestamp,\n        uint256 _reductionAmount\n    ) {\n        DistributionReduction memory lastReduction;\n\n        if (distributionReductions.length > 0) {\n            lastReduction = distributionReductions[\n                distributionReductions.length - 1\n            ];\n        } else {\n            lastReduction = DistributionReduction(\n                distributionStartTimestamp,\n                initialDaylyDistribution\n            );\n        }\n\n        require(\n            _reductionTimestamp >=\n                lastReduction.reductionTimestamp + 10 minutes,\n            \"JAKANTMasterDistributor: New redution start time cannot be lower than 10 minutes after last redution timestamp\"\n        );\n        require(\n            _reductionAmount >= lastReduction.daylyDistribution.div(2),\n            \"JAKANTMasterDistributor: New reduction amount cannot be greater than half of the last reduction amount\"\n        );\n        require(\n            _reductionAmount <= lastReduction.daylyDistribution.mul(2),\n            \"JAKANTMasterDistributor: New reduction amount cannot be greater than the last reduction amount multiplied by 2\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure that the provided address is not blocklisted.\n     *\n     * This modifier is used to validate that the `_account` address passed as an argument is not\n     * blocklisted within the contract. Addresses that are blocklisted may have certain restrictions\n     * or limitations imposed on them by the contract, and this modifier helps prevent blocklisted\n     * addresses from participating in specific operations.\n     *\n     * If the `_account` address is blocklisted, the contract will revert with the message \"JAKANTMasterDistributor: Action on blocklisted account\"\n     * If the address is not blocklisted, the modified function or operation is executed as intended.\n     */\n    modifier notBlocklisted(address _account) {\n        require(\n            !blocklisted[_account],\n            \"JAKANTMasterDistributor: Action on blocklisted account\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure that the provided address is not the zero address.\n     *\n     * This modifier is used to validate that the `_account` address passed as an argument is not\n     * equal to the zero address (`address(0)`). Preventing the zero address from being used in\n     * certain contexts can help avoid unexpected behavior, as the zero address often has special\n     * significance.\n     *\n     * If the `_account` address is the zero address, the contract will revert with the error code \"Action on address zero\"\n     * If the address is valid (not zero), the modified function or operation is executed.\n     */\n    modifier notZeroAddress(address _account) {\n        require(\n            _account != address(0),\n            \"JAKANTMasterDistributor: Action on address zero\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier that ensures a role has not already been assigned to an account. This modifier checks\n     * the status of a role in the `assignedRoles` mapping. If the role has already been granted (i.e., the\n     * corresponding value in the mapping is `true`), the function call is reverted with an error message.\n     * This is used to prevent roles from being granted to more than one account, ensuring unique assignment\n     * of responsibilities or permissions within the contract.\n     *\n     * @param _role The bytes32 identifier of the role to check.\n     */\n    modifier notGranted(bytes32 _role) {\n        require(\n            !assignedRoles[_role],\n            \"JAKANTMasterDistributor: Role already granted to another account\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if a role has not been marked as burned. A role is considered burned if\n     * it has been explicitly revoked and cannot be reassigned. This is typically done by assigning the role\n     * to the zero address. The modifier uses the `hasRole` function to check the status of the role.\n     * If the role is found to be assigned to the zero address, indicating that it has been burned, the\n     * function call is reverted with an error message. This prevents operations on roles that are meant to\n     * be permanently inactive or revoked.\n     *\n     * @param _role The bytes32 identifier of the role to check.\n     */\n    modifier notBurned(bytes32 _role) {\n        require(\n            !hasRole(_role, address(0)),\n            \"JAKANTMasterDistributor: Role is already burned\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Constructor for the contract. Initializes the contract by setting the distribution start timestamp,\n     * the distribution deadline, and assigning the OWNER_ROLE to the provided owner address. The distribution\n     * start timestamp is set to 14 days from the current block time, providing a preparation period before the\n     * distribution begins. The distribution deadline is set to 30 days from the current block time, creating a\n     * finite period for the distribution process. The OWNER_ROLE is crucial for contract administration and\n     * oversight, allowing the owner to manage the contract's key operations.\n     *\n     * @param _owner The address that will be assigned the OWNER_ROLE, granting administrative control over the contract.\n     */\n    constructor(address _owner) {\n        // Set the distribution start timestamp to 14 days from the current block time.\n        // This delay allows for a preparation period before the distribution begins.\n        distributionStartTimestamp = block.timestamp + 1 days;\n        // Set the deadline for the distribution period to 30 days from the current block time.\n        // This sets a finite period for the distribution process, ensuring a clear end date.\n        distributionStartTimestampDeadLine = block.timestamp + 10 days;\n        // Assign the OWNER_ROLE to the provided owner address. This role typically includes\n        // elevated privileges and is crucial for contract administration and oversight.\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Calculates the total token distribution based on the initial daily distribution, the elapsed time,\n     * and any distribution reductions that have been set. The function first checks if the current timestamp\n     * is past the distribution start timestamp. If not, it returns 0, indicating that distribution has not\n     * started yet. If the distribution has started, it calculates the total distribution by taking into\n     * account the initial daily distribution and adjusting it based on any reductions that have occurred\n     * since the start of the distribution.\n     *\n     * The function iterates through each distribution reduction, checks if the current timestamp is greater\n     * than the reduction timestamp, and, if so, calculates the distribution for the time period since the last\n     * reduction. It updates the total distribution accordingly. The total distribution also includes the\n     * distribution for the period from the start timestamp until the first reduction or the current time,\n     * whichever comes first.\n     *\n     * @return The total token distribution up to the current block timestamp.\n     */\n    function getAllTokenDistribution() public view returns (uint256) {\n        if (block.timestamp < distributionStartTimestamp) {\n            return 0;\n        }\n\n        uint256 totalDistribution = initialDaylyDistribution;\n        // Time periods since last distribution\n        uint256 timeElapsed = block.timestamp - distributionStartTimestamp;\n        uint256 daysElapsed = timeElapsed / SECONDS_PER_DAY;\n\n        uint256 reductionEndTimestamp = block.timestamp;\n\n        if (distributionReductions.length == 0) {\n            return totalDistribution + daysElapsed * initialDaylyDistribution;\n        }\n\n        for (\n            uint256 index = distributionReductions.length - 1;\n            index >= 0;\n            index--\n        ) {\n            DistributionReduction\n                memory distributionReduction = distributionReductions[index];\n\n            // Check if the current timestamp is greater than the reduction timestamp\n            if (block.timestamp >= distributionReduction.reductionTimestamp) {\n                // Calculate the number of days in the current period\n                uint256 daysInCurrentPeriod = (reductionEndTimestamp -\n                    distributionReduction.reductionTimestamp) / SECONDS_PER_DAY;\n                totalDistribution +=\n                    distributionReduction.daylyDistribution +\n                    (daysInCurrentPeriod *\n                        distributionReduction.daylyDistribution);\n                // Update timestamp for previous period\n                reductionEndTimestamp = distributionReduction\n                    .reductionTimestamp;\n                // Update daysElapsed for previous period\n                daysElapsed -= daysInCurrentPeriod;\n                // Check if we have reached the start of the distribution reduction\n                if (index == 0) {\n                    break;\n                }\n            }\n        }\n\n        totalDistribution += daysElapsed * initialDaylyDistribution;\n\n        return totalDistribution >= mproToken.maxCap()\n            ? mproToken.maxCap()\n            : totalDistribution;\n    }\n\n    /**\n     * @dev Calculates the quantity of tokens that are available for distribution at the current time.\n     * It determines this quantity by subtracting the total number of tokens already distributed\n     * (`distributedTokens`) from the total number of tokens that should have been distributed up to the\n     * current point in time (`getAllTokenDistribution`). This function provides insight into the remaining\n     * token balance that is available for distribution, ensuring that the distribution does not exceed\n     * the planned amount at any given point.\n     *\n     * Note that this is a public function and can only be called within the contract itself. This function\n     * is typically used internally to manage and track the distribution process accurately.\n     *\n     * @return The quantity of tokens that are currently available for distribution.\n     */\n    function getAvailableForDistributionTokenQuantity()\n        public\n        view\n        returns (uint256)\n    {\n        return getAllTokenDistribution().sub(distributedTokens);\n    }\n\n    /**\n     * @dev Distributes a specified amount of tokens to a given address.\n     *\n     * This function allows tokens to be minted and distributed to a specified address.\n     * It can only be called by an account with the JAKANT_MASTER_DISTRIBUTOR_ROLE.\n     * The function performs several checks before proceeding with the distribution:\n     * - It ensures that the amount to be distributed is greater than 0.\n     * - It verifies that the current timestamp is greater than or equal to the distributionStartTimestamp,\n     *   ensuring that the distribution period has started.\n     * - It checks that the total amount of tokens to be distributed (including the current distribution)\n     *   does not exceed the quantity available for distribution as determined by\n     *   getAvailableForDistributionTokenQuantity.\n     *\n     * If all checks pass, the function increments the distributedTokens state variable by the amount\n     * to be distributed and calls the mint function on the mproToken contract to mint the tokens\n     * to the specified address.\n     *\n     * @param _to The address to which the tokens will be distributed.\n     * @param _amount The amount of tokens to be distributed.\n     */\n    function distribute(\n        address _to,\n        uint256 _amount\n    ) public onlyRole(JAKANT_MASTER_DISTRIBUTOR_ROLE) {\n        require(_amount > 0, \"amount must be greater than 0\");\n        require(\n            block.timestamp >= distributionStartTimestamp,\n            \"JAKANTMasterDistributor: Distribution is not enabled yet\"\n        );\n        require(\n            _amount <= getAvailableForDistributionTokenQuantity(),\n            \"JAKANTMasterDistributor: Distribution limit exceeded\"\n        );\n\n        mproToken.mint(_to, _amount);\n        distributedTokens += _amount;\n\n        emit Distributed(_to, _amount);\n    }\n\n    /**\n     * @dev Distributes tokens to multiple addresses in bulk.\n     *\n     * This function allows for the bulk distribution of tokens to a list of addresses, each receiving\n     * a specified amount. It is designed to efficiently handle multiple distributions in a single transaction.\n     * The function can only be invoked by an account with the JAKANT_MASTER_DISTRIBUTOR_ROLE.\n     *\n     * The function performs the following checks and operations:\n     * - It ensures that the length of the `_to` address array matches the length of the `_amount` array,\n     *   ensuring each address has a corresponding amount to be distributed.\n     * - It then iterates over these arrays, calling the `distribute` function for each address-amount pair.\n     *   The `distribute` function is responsible for the actual minting and transferring of tokens,\n     *   as well as performing necessary checks such as ensuring the distribution period has started and\n     *   that the total distributed amount does not exceed the available quantity.\n     *\n     * Note: This function relies on the `distribute` function for individual distributions and inherits\n     * its checks and limitations. Each distribution in the loop is treated as a separate transaction in\n     * terms of checks and effects.\n     *\n     * @param _to An array of addresses to which tokens will be distributed.\n     * @param _amount An array of token amounts to be distributed to the respective addresses.\n     */\n    function distributeBulk(\n        address[] memory _to,\n        uint256[] memory _amount\n    ) public onlyRole(JAKANT_MASTER_DISTRIBUTOR_ROLE) {\n        require(\n            _to.length == _amount.length,\n            \"to and amount arrays must have the same length\"\n        );\n        for (uint256 i = 0; i < _to.length; i++) {\n            distribute(_to[i], _amount[i]);\n        }\n    }\n\n    /**\n     * @dev Sets a new distribution start time.\n     *\n     * This function allows the contract owner to set a new start time\n     * for the token distribution process. It ensures that the new start time is in the future, has not yet been\n     * surpassed, and is before the predefined distribution start timestamp deadline. This function can only be\n     * called if the distribution has not yet started (i.e., no tokens have been distributed).\n     *\n     * The function includes checks to ensure:\n     * 1. The distribution has not yet started (`distributedTokens` must be 0).\n     * 2. The new start time (`_startTime`) is in the future (greater than the current `block.timestamp`).\n     * 3. The new start time does not exceed the predefined deadline (`distributionStartTimestampDeadLine`).\n     *\n     * If all conditions are met, the function updates the `distributionStartTimestamp` and emits a\n     * `SetDistribiutionStartTime` event with the new start time.\n     *\n     * @param _startTime The new start time for token distribution.\n     */\n    function setDistributionStartTime(uint256 _startTime) external onlyOwner {\n        require(\n            distributedTokens == 0,\n            \"JAKANTMasterDistributor: Distribution start time cannot be changed after distribution has started\"\n        );\n        require(\n            _startTime > block.timestamp,\n            \"JAKANTMasterDistributor: Distribution start time cannot be lower than current time\"\n        );\n        require(\n            _startTime <= distributionStartTimestampDeadLine,\n            \"JAKANTMasterDistributor: Distribution start time must be less than distributionStartTimeDeadline\"\n        );\n\n        distributionStartTimestamp = _startTime;\n\n        emit SetDistribiutionStartTime(_startTime);\n    }\n\n    /**\n     * @dev Adds a new distribution reduction to the contract.\n     *\n     * This external function allows an account with the DISTRIBUTIONS_ADMINISTRATOR_ROLE to add a\n     * new distribution reduction. A distribution reduction is a record that signifies a change in the\n     * distribution amount of tokens from a specific timestamp.\n     *\n     * The function includes a modifier `reductionEnabled` which likely contains logic to validate the\n     * input parameters `_redutionTimestamp` and `_reductionAmount`. It ensures that the reduction\n     * parameters meet certain criteria before allowing the addition of the new reduction.\n     *\n     * Once validated, the function appends a new `DistributionReduction` struct to the\n     * `distributionReductions` array. This struct includes the timestamp from which the reduction\n     * should take effect (`_redutionTimestamp`) and the new amount to be distributed from that\n     * timestamp (`_reductionAmount`).\n     *\n     * @param _redutionTimestamp The timestamp from which the new distribution amount should apply.\n     * @param _reductionAmount The new amount to be distributed from the specified timestamp.\n     */\n    function addDistributionReduction(\n        uint256 _redutionTimestamp,\n        uint256 _reductionAmount\n    )\n        external\n        onlyRole(DISTRIBUTIONS_ADMINISTRATOR_ROLE)\n        reductionEnabled(_redutionTimestamp, _reductionAmount)\n    {\n        distributionReductions.push(\n            DistributionReduction(_redutionTimestamp, _reductionAmount)\n        );\n\n        emit AddDistributionReduction(_redutionTimestamp, _reductionAmount);\n    }\n\n    /**\n     * @dev Sets the address of the MPRO token contract. This function allows the contract owner to set or\n     * update the address of the MPRO token contract to be used in the distribution. It includes a check to ensure\n     * that the MPRO token address is not already set, preventing accidental overwriting of the token address.\n     *\n     * This is a critical function as it establishes the link to the MPRO token that will be distributed by this\n     * contract. The function can only be successfully called once, as the MPRO token address is intended to be\n     * immutable once set to prevent unauthorized changes.\n     *\n     * If the token address has not been set before, the function updates the `mproToken` state variable and emits\n     * a `SetJAKANTToken` event with the new MPRO token address.\n     *\n     * @param _mproTokenAddress The address of the MPRO token contract to be set.\n     */\n    function setJAKANTToken(address _mproTokenAddress) external onlyOwner {\n        require(\n            mproToken == IJAKANTToken(address(0)),\n            \"JAKANTMasterDistributor: MPRO token is already set\"\n        );\n        mproToken = IJAKANTToken(_mproTokenAddress);\n        emit SetJAKANTToken(_mproTokenAddress);\n    }\n\n    /**\n     * @dev Calculates the amount to be burned based on the burn rate.\n     *\n     * This function calculates the amount of tokens that should be burned from a given transaction\n     * amount, based on the current burn rate. The burn rate is applied unless the sender's address\n     * is whitelisted, in which case no tokens are burned.\n     *\n     * The function performs the following operations:\n     * - It checks if the sender (`_from`) is whitelisted using the `mproRoleManager.isWhitelisted`\n     *   function. If the sender is whitelisted, the function returns 0, indicating no burn is applied.\n     * - If the sender is not whitelisted, the function calculates the burn amount by applying the\n     *   burn rate to the transaction amount (`_amount`). The burn rate is represented as a percentage\n     *   scaled by a factor of 10000 (e.g., a burn rate of 10% is represented as 1000). The calculated\n     *   burn amount is then returned.\n     *\n     * This mechanism allows for a dynamic burn policy where certain addresses can be exempted from\n     * burning, potentially for promotional or operational purposes.\n     *\n     * @param _from The address from which the tokens are being transferred.\n     * @param _amount The amount of tokens being transferred, from which the burn amount will be calculated.\n     * @return The calculated amount of tokens to be burned.\n     */\n    function getBurnAmount(\n        address _from,\n        uint256 _amount\n    ) external view returns (uint256) {\n        // If the sender is whitelisted, no burn fee is applied\n        if (isWhitelisted(_from)) {\n            return 0;\n        }\n        return _amount.mul(burnRate).div(10000);\n    }\n\n    /**\n     * @dev Sets the burn rate for the contract.\n     *\n     * This external function allows an account with the OWNER_ROLE to set the burn rate,\n     * which is the percentage of the tokens that will be burned during certain operations.\n     * The burn rate is expressed as a percentage with a precision of up to three decimal places.\n     * For example, a burn rate of 1000 represents a 10% burn rate (1000 / 100 = 10%).\n     *\n     * A constraint is enforced to ensure that the burn rate does not exceed 10% (represented as 1000\n     * in the contract). This safeguard prevents setting an excessively high burn rate that could\n     * adversely impact the token economy or operations of the contract.\n     *\n     * It's critical to input the correct value for the burn rate as it directly affects the token\n     * dynamics. Only authorized accounts with the OWNER_ROLE can perform this operation, ensuring\n     * that the burn rate is controlled and updated responsibly.\n     *\n     * @param _burnRate The new burn rate to be set, scaled by a factor of 100. For example, to set a\n     *                 burn rate of 1%, `_burnFee` should be 10.\n     */\n    function setBurnRate(uint256 _burnRate) external onlyOwner {\n        require(\n            _burnRate <= 1000,\n            \"JAKANTMasterDistributor: Burn rate cannot be greater than or equal to 10%\"\n        );\n        burnRate = _burnRate;\n        emit SetBurnRate(_burnRate);\n    }\n\n    /**\n     * @dev Assigns the DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER role to a specified address. This function\n     * allows the contract owner to delegate the management of distribution time administrators to a specific\n     * account. This is crucial for decentralized management and control over the distribution process.\n     *\n     * The function includes checks to ensure:\n     * 1. The role has not been burned (permanently deactivated).\n     * 2. The role has not already been granted to another account.\n     *\n     * If the role is available and active, the function grants the DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER role\n     * to the specified address, marks the role as assigned in the `assignedRoles` mapping, and emits a\n     * `SetDistributorTimeAdministratorRoleManager` event with the address of the new role manager.\n     *\n     * @param _roleManagerAddress The address to be assigned the DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER role.\n     */\n    function setDistributorTimeAdministratorRoleManager(\n        address _roleManagerAddress\n    )\n        external\n        onlyOwner\n        notBurned(DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER)\n        notGranted(DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER)\n    {\n        _grantRole(\n            DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER,\n            _roleManagerAddress\n        );\n        assignedRoles[DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER] = true;\n        emit SetDistributorTimeAdministratorRoleManager(_roleManagerAddress);\n    }\n\n    /**\n     * @dev Assigns the DISTRIBUTIONS_ADMINISTRATOR_ROLE to a specified address. This function allows an account\n     * with the DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER role to delegate the responsibilities of distribution\n     * time administration to a specific account. This role is crucial for managing the distribution schedule\n     * and ensuring the proper administration of the distribution process.\n     *\n     * The function includes checks to ensure:\n     * 1. The caller has the DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER role, allowing them to manage this role.\n     * 2. The DISTRIBUTIONS_ADMINISTRATOR_ROLE has not been burned (permanently deactivated).\n     * 3. The DISTRIBUTIONS_ADMINISTRATOR_ROLE has not already been granted to another account.\n     *\n     * If the role is available and active, the function grants the DISTRIBUTIONS_ADMINISTRATOR_ROLE to the\n     * specified address, marks the role as assigned in the `assignedRoles` mapping, and emits a\n     * `SetDistributorTimeAdministratorRole` event with the address of the new role administrator.\n     *\n     * @param _roleManagerAddress The address to be assigned the DISTRIBUTIONS_ADMINISTRATOR_ROLE.\n     */\n    function setDistributorTimeAdministratorRole(\n        address _roleManagerAddress\n    )\n        external\n        onlyRole(DISTRIBUTIONS_ADMINISTRATOR_ROLE_MANAGER)\n        notBurned(DISTRIBUTIONS_ADMINISTRATOR_ROLE)\n        notGranted(DISTRIBUTIONS_ADMINISTRATOR_ROLE)\n    {\n        _grantRole(DISTRIBUTIONS_ADMINISTRATOR_ROLE, _roleManagerAddress);\n        assignedRoles[DISTRIBUTIONS_ADMINISTRATOR_ROLE] = true;\n        emit SetDistributorTimeAdministratorRole(_roleManagerAddress);\n    }\n\n    /**\n     * @dev Public function to grant a specific role to an account.\n     *\n     * This function allows the contract owner to grant a specific role to the `_account` address. Roles\n     * are used to define permissions and responsibilities within the contract, and granting a role confers\n     * those associated privileges to the specified account.\n     *\n     * The function takes two parameters:\n     * - `_role`: The bytes32 identifier of the role to be granted.\n     * - `_account`: The address to which the role is to be granted.\n     *\n     * As a safeguard, the function enforces several preconditions before granting the role:\n     * - Ensures that the `_account` address is not blocklisted, maintaining the security and integrity\n     *   of the contract by preventing potentially malicious entities from gaining privileged access.\n     * - Checks that the `_account` address is not the zero address (`address(0)`), avoiding unintentional\n     *   role assignments to an address that may have special significance or represent \"no address\".\n     * - Verifies that the role has not already been burned, ensuring that only active, valid roles are\n     *   assignable.\n     * - Confirms that the role has not already been granted, upholding the principle of unique role assignments.\n     *\n     * This function can only be called by the contract owner, ensuring that role management is kept under\n     * tight control and preventing unauthorized role assignments.\n     *\n     * @param _role The bytes32 identifier of the role to be granted.\n     * @param _account The address to which the role is to be granted.\n     *\n     * Requirements:\n     * - The contract caller must be the contract owner.\n     * - The `_account` must not be blocklisted or the zero address.\n     * - The `_role` must not be burned or already granted.\n     */\n    function grantRole(\n        bytes32 _role,\n        address _account\n    )\n        public\n        virtual\n        override\n        onlyOwner\n        notBlocklisted(_account)\n        notZeroAddress(_account)\n        notBurned(_role)\n        notGranted(_role)\n    {\n        assignedRoles[_role] = true;\n        _grantRole(_role, _account);\n    }\n\n    /**\n     * @dev Public function to revoke a specific role from an account.\n     *\n     * This function allows the contract owner to remove a previously granted role from the `_account` address.\n     * Roles are crucial for defining permissions and responsibilities within the contract, and revoking a role\n     * removes those associated privileges from the specified account.\n     *\n     * The function takes two parameters:\n     * - `_role`: The bytes32 identifier of the role to be revoked.\n     * - `_account`: The address from which the role is to be removed.\n     *\n     * Before revoking the role, the function performs the following checks:\n     * - Verifies that the `_account` address is not the zero address (`address(0)`) to prevent accidental\n     *   modifications of the zero address, which may have special significance.\n     * - Ensures that the `_account` currently has the role to be revoked, providing a safeguard against\n     *   unnecessary or mistaken revocations.\n     *\n     * Access to this function is restricted to addresses with the `OWNER_ROLE`, ensuring that only contract\n     * owners or administrators can revoke roles. Upon successful revocation of the role, the function updates\n     * the `assignedRoles` mapping and calls the internal `_revokeRole` function.\n     *\n     * @param _role The bytes32 identifier of the role to be revoked.\n     * @param _account The address from which the role is to be removed.\n     *\n     * Requirements:\n     * - The `_account` address must not be the zero address (`address(0)`).\n     * - The `_account` must currently have the role that is being revoked.\n     */\n    function revokeRole(\n        bytes32 _role,\n        address _account\n    ) public override onlyOwner notZeroAddress(_account) {\n        require(\n            hasRole(_role, _account),\n            \"JAKANTMasterDistributor: Account does not have role\"\n        );\n        assignedRoles[_role] = false;\n        _revokeRole(_role, _account);\n    }\n\n    /**\n     * @dev Public function for an account to renounce a specific role it possesses.\n     *\n     * This function allows an account to voluntarily renounce a role it holds, effectively removing the\n     * associated permissions and responsibilities. It's a self-initiated action, meaning an account can\n     * only renounce roles that it possesses for itself, enhancing the security by preventing external\n     * entities from forcibly removing roles.\n     *\n     * The function takes two parameters:\n     * - `_role`: The bytes32 identifier of the role to be renounced.\n     * - `_account`: The address of the account renouncing the role. To ensure security and prevent\n     *   unintended renunciations, the function checks that `_account` is the same as `_msgSender()`.\n     *\n     * Before allowing the role to be renounced, the function performs the following check:\n     * - Verifies that the `_account` address is not the zero address (`address(0)`) to prevent\n     *   accidental modifications of the zero address, which may have special significance.\n     *\n     * Upon successfully renouncing the role, the function updates the `assignedRoles` mapping and\n     * calls the internal `_revokeRole` function to formally remove the role.\n     *\n     * @param _role The bytes32 identifier of the role to be renounced.\n     * @param _account The address of the account renouncing the role.\n     *\n     * Requirements:\n     * - The `_account` address must not be the zero address (`address(0)`).\n     * - The `_account` must be the same as `_msgSender()`, ensuring that accounts can only renounce\n     *   roles for themselves.\n     */\n    function renounceRole(\n        bytes32 _role,\n        address _account\n    ) public override notZeroAddress(_account) {\n        require(\n            _account == _msgSender(),\n            \"AccessControl: can only renounce roles for self\"\n        );\n        require(\n            hasRole(_role, _account),\n            \"JAKANTMasterDistributor: Account does not have role\"\n        );\n        assignedRoles[_role] = false;\n        _revokeRole(_role, _account);\n    }\n\n    /**\n     * @dev External function to blocklist or unblocklist an account.\n     *\n     * This function allows an address with the `LISTER_ROLE` to either blocklist or remove an account\n     * from the contract's blocklist. Blocklisting an account may restrict it from performing certain\n     * operations or participating in specific aspects of the contract, as defined by the contract's\n     * logic.\n     *\n     * The function takes two parameters:\n     * - `_account`: The address to be either blocklisted or unblocklisted.\n     * - `_blocklist`: A boolean indicating whether to blocklist (`true`) or unblocklist (`false`)\n     *   the account.\n     *\n     * Before modifying the blocklist status, the function checks if the specified `_account` address\n     * holds any other roles within the contract (owner, lister, pauser, distributor). If the account\n     * has any of these roles, the function reverts to prevent the blocklisting of accounts with\n     * roles.\n     *\n     * Access to this function is restricted to addresses with the `LISTER_ROLE`, ensuring that only\n     * authorized entities can modify the blocklist.\n     *\n     * @param _account The address to be blocklisted or unblocklisted.\n     * @param _blocklist A boolean indicating whether to blocklist or unblocklist the account.\n     *\n     * Requirements:\n     * - The `_account` address must not be the zero address (`address(0)`).\n     *   This prevents accidentally modifying the zero address, which may have special significance.\n     * - The `_account` address must not have any other roles (owner, lister, pauser, distributor).\n     *   Accounts with these roles cannot be blocklisted.\n     */\n\n    function blocklist(\n        address _account,\n        bool _blocklist\n    ) external onlyRole(LISTER_ROLE) notZeroAddress(_account) {\n        if (\n            this.owner() == _account ||\n            isLister(_account) ||\n            isDistributor(_account)\n        ) {\n            revert(\n                \"JAKANTMasterDistributor: Account has a role and cannot be blocklisted\"\n            );\n        }\n        blocklisted[_account] = _blocklist;\n    }\n\n    /**\n     * @dev External function to whitelist or unwhitelist an account.\n     *\n     * This function allows an address with the `LISTER_ROLE` to either whitelist or remove an account\n     * from the contract's whitelist. Whitelisting typically grants certain privileges or exemptions\n     * to the whitelisted account, while removing an account from the whitelist revokes these\n     * privileges.\n     *\n     * The function takes two parameters:\n     * - `_account`: The address to be either whitelisted or removed from the whitelist.\n     * - `_whitelist`: A boolean indicating whether to whitelist (`true`) or unwhitelist (`false`)\n     *   the account.\n     *\n     * The function sets the whitelisting status of the specified account by updating the `whitelisted`\n     * mapping accordingly.\n     *\n     * Access to this function is restricted to addresses with the `LISTER_ROLE`, ensuring that only\n     * authorized entities can modify the whitelist.\n     *\n     * @param _account The address to be whitelisted or unwhitelisted.\n     * @param _whitelist A boolean indicating whether to whitelist or unwhitelist the account.\n     *\n     * Requirements:\n     * - The `_account` address must not be the zero address (`address(0)`).\n     *   This prevents accidentally modifying the zero address, which may have special significance.\n     */\n\n    function whitelist(\n        address _account,\n        bool _whitelist\n    ) external onlyRole(LISTER_ROLE) notZeroAddress(_account) {\n        whitelisted[_account] = _whitelist;\n    }\n\n    /**\n     * @dev Public view function to check if an account has the LISTER_ROLE.\n     *\n     * This function provides a convenient way to verify if a specific account has been granted the LISTER_ROLE\n     * within the contract. The LISTER_ROLE is typically associated with permissions to list items or manage\n     * lists within the contract's ecosystem.\n     *\n     * The function takes a single parameter:\n     * - `_account`: The address of the account to check for the LISTER_ROLE.\n     *\n     * It returns a boolean value indicating whether the specified account has the LISTER_ROLE. This can be\n     * particularly useful for front-end interfaces or other contract interactions that require a quick check\n     * of an account's roles or permissions.\n     *\n     * @param _account The address of the account to check for the LISTER_ROLE.\n     * @return A boolean value indicating whether the specified account has the LISTER_ROLE.\n     */\n    function isLister(address _account) public view returns (bool) {\n        return hasRole(LISTER_ROLE, _account);\n    }\n\n    /**\n     * @dev Public view function to check if an address has the JAKANTMasterDistributor role.\n     *\n     * This function provides a straightforward method to verify if a specific address has been granted the\n     * JAKANTMasterDistributor role within the contract. The JAKANTMasterDistributor role is typically associated\n     * with permissions to manage and execute token distributions, making it a critical role for the\n     * operational aspects of the contract.\n     *\n     * The function takes a single parameter:\n     * - `_address`: The address of the account to check for the JAKANTMasterDistributor role.\n     *\n     * It returns a boolean value indicating whether the specified address has the JAKANTMasterDistributor role.\n     * This is particularly useful for confirming role assignments and managing access to distribution-related\n     * functions or sections of a dApp interface.\n     *\n     * @param _address The address of the account to check for the JAKANTMasterDistributor role.\n     * @return A boolean value indicating whether the specified address has the JAKANTMasterDistributor role.\n     */\n    function isDistributor(address _address) public view returns (bool) {\n        return hasRole(JAKANT_MASTER_DISTRIBUTOR_ROLE, _address);\n    }\n\n    /**\n     * @dev Public view function to check if an account is blocklisted.\n     *\n     * This function allows anyone to determine if a specific account is included in the contract's\n     * blocklist. An account that is blocklisted may be restricted from performing certain operations\n     * or participating in specific aspects of the contract, as defined by the contract's logic.\n     *\n     * The function checks the `blocklisted` mapping to see if the provided `_account` address is\n     * marked as blocklisted, returning a boolean value indicating the blocklist status.\n     *\n     * Being a `view` function, it only reads the blocklist status from the contract's state and\n     * does not modify the contract. This function is typically used in access control mechanisms\n     * where actions are conditional based on whether an account is blocklisted.\n     *\n     * @param _account The address to be checked for blocklist status.\n     * @return `true` if the account is blocklisted, `false` otherwise.\n     */\n\n    function isBlocklisted(address _account) public view returns (bool) {\n        return blocklisted[_account];\n    }\n\n    /**\n     * @dev External view function to check if an account is whitelisted.\n     *\n     * This function is accessible externally and is used to determine if a specific account is\n     * included in the whitelist of the contract. Whitelisted accounts often have certain privileges\n     * or are exempt from various restrictions that apply to other users.\n     *\n     * The function's logic is as follows:\n     * - If the provided `_account` address is the zero address (`address(0)`), the function\n     *   returns `true`. This implies a default allowance or special treatment for the zero address\n     *   in certain contexts.\n     * - For any other address, it checks the `whitelisted` mapping to see if the address is\n     *   marked as whitelisted, returning a boolean value that indicates the status.\n     *\n     * Being a `view` function, it does not modify the state of the contract but simply reads and\n     * returns the whitelisting status. It is typically used in access control checks, where\n     * different actions or permissions are granted based on the user's whitelist status.\n     *\n     * @param _account The address to be checked for its whitelisted status.\n     * @return `true` if the account is whitelisted, `false` otherwise.\n     */\n\n    function isWhitelisted(address _account) public view returns (bool) {\n        if (_account == address(0)) {\n            return true;\n        }\n        return whitelisted[_account];\n    }\n\n    /**\n     * @dev External view function to check if minting is allowed for a given address.\n     *\n     * This function checks whether the provided `_minter` address is authorized to mint new tokens.\n     * In the current implementation, minting is restricted to the contract itself, signifying that\n     * minting operations are controlled internally and not open to external entities directly.\n     *\n     * The function takes a single parameter:\n     * - `_minter`: The address to be checked for minting permissions.\n     *\n     * It returns true if the `_minter` address is the same as the address of this contract,\n     * indicating that minting is allowed. Otherwise, it reverts the transaction with the message\n     * \"JAKANTMasterDistributor: Distributor only\", enforcing the rule that only the contract itself can initiate minting operations.\n     *\n     * @param _minter The address to be checked for minting permissions.\n     * @return A boolean value indicating whether minting is allowed for the specified `_minter` address.\n     */\n    function mintAllowed(address _minter) external view returns (bool) {\n        require(\n            _minter == address(this),\n            \"JAKANTMasterDistributor: Distributor only\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Public view function to check if a token transfer is allowed.\n     *\n     * This function is used to enforce restrictions on token transfers based on blocklist criteria.\n     * It checks whether any of the involved parties in a token transfer (the sender, receiver, and\n     * the caller of the function) are on a blocklist. If any of these addresses are blocklisted, the\n     * function reverts the transaction, preventing the transfer.\n     *\n     * Being a `view` function, it does not modify the state of the blockchain but reads from it.\n     * This function can be integrated into the token transfer process to add an additional layer of\n     * security and compliance, ensuring that tokens cannot be transferred by or to blocklisted\n     * addresses.\n     *\n     * @param _from The address attempting to send tokens.\n     * @param _to The address intended to receive the tokens.\n     * @param _msgSender The address initiating the transfer request.\n     *\n     * Requirements:\n     * - None of the involved addresses (_from, _to, and _msgSender) can be on the blocklist.\n     *   If any are blocklisted, the function reverts with an error message.\n     */\n\n    function transferAllowed(\n        address _from,\n        address _to,\n        address _msgSender\n    ) external view returns (bool) {\n        require(\n            !isBlocklisted(_from) &&\n                !isBlocklisted(_to) &&\n                !isBlocklisted(_msgSender),\n            \"JAKANTMasterDistributor: Action on blocklisted account\"\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Public view function to check if token approval is allowed.\n     *\n     * This function is used to enforce restrictions on token approvals based on blocklist criteria.\n     * It checks whether the spender or the caller of the function (message sender) are on a\n     * blocklist. If either of these addresses are blocklisted, the function reverts the transaction,\n     * preventing the approval operation.\n     *\n     * This check is crucial in scenarios where blocklisted addresses should not be permitted to\n     * interact with the token, including being approved to spend tokens on behalf of others. By\n     * incorporating this function into the approval process, the contract adds an additional layer\n     * of security and regulatory compliance.\n     *\n     * Being a `view` function, `approveAllowed` does not alter the state of the blockchain but\n     * reads from it to ensure compliance with the blocklist rules before any approval is granted.\n     *\n     * @param _spender The address being granted permission to spend tokens.\n     * @param _msgSender The address initiating the approval request.\n     *\n     * Requirements:\n     * - Neither the spender (_spender) nor the initiator of the approval (_msgSender) can be\n     *   on the blocklist. If any of them are blocklisted, the function reverts with an error message.\n     */\n\n    function approveAllowed(\n        address _spender,\n        address _msgSender\n    ) external view returns (bool) {\n        require(\n            !isBlocklisted(_spender) && !isBlocklisted(_msgSender),\n            \"JAKANTMasterDistributor: Action on blocklisted account\"\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev External view function to retrieve the list of distribution reductions.\n     *\n     * This function provides access to the array of `distributionReductions`, which contains\n     * records of all the reductions applied to the token distribution over time. Each record in\n     * the array is a `DistributionReduction` struct, detailing the timestamp when the reduction\n     * takes effect and the new daily distribution amount after the reduction.\n     *\n     * The function does not take any parameters and returns the entire array of\n     * `distributionReductions`. This can be particularly useful for front-end interfaces or\n     * other contract interactions that require visibility into the history and schedule of\n     * distribution reductions.\n     *\n     * @return An array of `DistributionReduction` structs, representing the history of distribution reductions.\n     */\n    function getDistributionReductions()\n        external\n        view\n        returns (DistributionReduction[] memory)\n    {\n        return distributionReductions;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}